#include "../src/BitStreamReader.h"
#include "../src/BitStreamReader.cpp"
#include "../src/CLIArgParser.h"
#include "../src/CLIArgParser.cpp"
#include "../src/ESETVM.h"
#include "../src/EVMDisasm.h"
#include "../src/EVMDisasm.cpp"
#include "../src/EVMFile.h"
#include "../src/EVMFile.cpp"
#include "../src/utils.h"
#include "../src/utils.cpp"
#include <vector>
#include <numeric>
#include <gtest/gtest.h>

#define S(x) #x
#define STR(x) S(x)

template<typename... Ts>
std::vector<std::byte> makeBytes(Ts&&... args)
{
	return{std::byte(std::forward<Ts>(args))...};
}

static const std::vector<std::byte> crcCodeTest = makeBytes(
	0x21, 0x1c, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x05, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0xd0 );

static const std::string crcBitStreamTest = "00100001000111001000000000000000000000000000000000000000000000000000011100111111111111111111111111111111111000000000000000000000000000000000010100100000000000000000000000000000000000000000000000000000000000000000110100100000000000000000000000000000000000000000000000000000000000000000001100110000000000000000000000000000000000000000000000000000000000000000101100100100000000000000000000000000000000000000000000000000000000000000100111010000";

static std::vector<EVMInstruction> crcInstructionsTest;

static const std::vector<std::byte> crcCodeFull = makeBytes (
	0x21, 0x1c, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x05, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x80, 0xd6, 0xd0, 0x39, 0x6f, 0x00, 0x00, 0x00, 0x0d, 0x13, 0x59, 0x91, 0x7a, 0x00, 0x00, 0x19, 0x0e, 0xe0, 0x00, 0x01, 0x97, 0x24, 0x00, 0x00, 0x00, 0x13, 0x44, 0xd0, 0x2a, 0x04, 0x81, 0x10, 0x2c, 0x02, 0x80, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x13, 0x2a, 0x0b, 0x90, 0xee, 0x00, 0x00, 0x19, 0x02, 0xa0, 0x00, 0x01, 0x97, 0x24, 0x00, 0x00, 0x00, 0x05, 0x44, 0x6b, 0x1b, 0x43, 0x60, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x03, 0x72, 0x2b, 0xc0, 0x00, 0x03, 0x21, 0xdc, 0x00, 0x00, 0x32, 0xe4, 0x80, 0x00, 0x02, 0x60, 0xb6, 0x44, 0x44, 0x00, 0x00, 0x64, 0x28, 0x40, 0x00, 0x06, 0x43, 0x68, 0x00, 0x00, 0x64, 0x5e, 0x80, 0x00, 0x06, 0x41, 0x18, 0x00, 0x00, 0x64, 0x69, 0x80, 0x00, 0x06, 0x42, 0x58, 0x00, 0x00, 0x64, 0x4d, 0x80, 0x00, 0x06, 0x40, 0x38, 0x00, 0x00, 0x64, 0x3b, 0x80, 0x00, 0x02, 0x45, 0x29, 0x52, 0x21, 0x08, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x18, 0x23, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x17, 0x0b, 0x70, 0x00, 0x00, 0x00, 0x8d, 0xe9, 0xe0, 0x00, 0x00, 0x70, 0x54, 0x80, 0x00, 0x02, 0x08, 0xc0, 0x11, 0x4c, 0x41, 0x0c, 0xc5, 0x05, 0x4c, 0x30, 0x4c, 0xe0, 0xa1, 0x00, 0x00, 0x05, 0x19, 0x12, 0x88, 0xad, 0x0a, 0x10, 0x00, 0x00, 0x74, 0xe8, 0x80, 0x00, 0x03, 0x04, 0x98, 0x9c, 0x26, 0xc0, 0x48, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x2a, 0x07, 0x01, 0x54, 0x39, 0x0d, 0x28, 0xe0, 0x00, 0x00, 0x05, 0x06, 0x40, 0x54, 0x00, 0x00, 0x64, 0x21, 0x40, 0x00, 0x06, 0x46, 0xe4, 0x00, 0x00, 0x64, 0x16, 0x40, 0x00, 0x06, 0x45, 0xa4, 0x00, 0x00, 0x64, 0x32, 0x40, 0x00, 0x06, 0x47, 0xc4, 0x00, 0x00, 0x64, 0x0c, 0x40, 0x00, 0x06, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x03, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x23, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x13, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x33, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x0b, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x2b, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x1b, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x3b, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x07, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x27, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x17, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x37, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x0f, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x72, 0x1c, 0x2f, 0xbe, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xe0, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xe8, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xe4, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xec, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xe2, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xea, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xe6, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xee, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xe1, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xe9, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xe5, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xed, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xe3, 0x48, 0xe4, 0x3e, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xeb, 0x48, 0xe4, 0x3e, 0x80
);

static const std::vector<uint8_t> multithreadedFileWrite = {
	0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00,
	0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x0f, 0x00,
	0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00, 0x14, 0x00, 0x15, 0x00, 0x16, 0x00, 0x17, 0x00,
	0x18, 0x00, 0x19, 0x00, 0x1a, 0x00, 0x1b, 0x00, 0x1c, 0x00, 0x1d, 0x00, 0x1e, 0x00, 0x1f, 0x00,
	0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x24, 0x00, 0x25, 0x00, 0x26, 0x00, 0x27, 0x00,
	0x28, 0x00, 0x29, 0x00, 0x2a, 0x00, 0x2b, 0x00, 0x2c, 0x00, 0x2d, 0x00, 0x2e, 0x00, 0x2f, 0x00,
	0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00,
	0x38, 0x00, 0x39, 0x00, 0x3a, 0x00, 0x3b, 0x00, 0x3c, 0x00, 0x3d, 0x00, 0x3e, 0x00, 0x3f, 0x00,
	0x40, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00, 0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00,
	0x48, 0x00, 0x49, 0x00, 0x4a, 0x00, 0x4b, 0x00, 0x4c, 0x00, 0x4d, 0x00, 0x4e, 0x00, 0x4f, 0x00,
	0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00, 0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00,
	0x58, 0x00, 0x59, 0x00, 0x5a, 0x00, 0x5b, 0x00, 0x5c, 0x00, 0x5d, 0x00, 0x5e, 0x00, 0x5f, 0x00,
	0x60, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x64, 0x00, 0x65, 0x00, 0x66, 0x00, 0x67, 0x00,
	0x68, 0x00, 0x69, 0x00, 0x6a, 0x00, 0x6b, 0x00, 0x6c, 0x00, 0x6d, 0x00, 0x6e, 0x00, 0x6f, 0x00,
	0x70, 0x00, 0x71, 0x00, 0x72, 0x00, 0x73, 0x00, 0x74, 0x00, 0x75, 0x00, 0x76, 0x00, 0x77, 0x00,
	0x78, 0x00, 0x79, 0x00, 0x7a, 0x00, 0x7b, 0x00, 0x7c, 0x00, 0x7d, 0x00, 0x7e, 0x00, 0x7f, 0x00,
	0x80, 0x00, 0x81, 0x00, 0x82, 0x00, 0x83, 0x00, 0x84, 0x00, 0x85, 0x00, 0x86, 0x00, 0x87, 0x00,
	0x88, 0x00, 0x89, 0x00, 0x8a, 0x00, 0x8b, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8e, 0x00, 0x8f, 0x00,
	0x90, 0x00, 0x91, 0x00, 0x92, 0x00, 0x93, 0x00, 0x94, 0x00, 0x95, 0x00, 0x96, 0x00, 0x97, 0x00,
	0x98, 0x00, 0x99, 0x00, 0x9a, 0x00, 0x9b, 0x00, 0x9c, 0x00, 0x9d, 0x00, 0x9e, 0x00, 0x9f, 0x00,
	0xa0, 0x00, 0xa1, 0x00, 0xa2, 0x00, 0xa3, 0x00, 0xa4, 0x00, 0xa5, 0x00, 0xa6, 0x00, 0xa7, 0x00,
	0xa8, 0x00, 0xa9, 0x00, 0xaa, 0x00, 0xab, 0x00, 0xac, 0x00, 0xad, 0x00, 0xae, 0x00, 0xaf, 0x00,
	0xb0, 0x00, 0xb1, 0x00, 0xb2, 0x00, 0xb3, 0x00, 0xb4, 0x00, 0xb5, 0x00, 0xb6, 0x00, 0xb7, 0x00,
	0xb8, 0x00, 0xb9, 0x00, 0xba, 0x00, 0xbb, 0x00, 0xbc, 0x00, 0xbd, 0x00, 0xbe, 0x00, 0xbf, 0x00,
	0xc0, 0x00, 0xc1, 0x00, 0xc2, 0x00, 0xc3, 0x00, 0xc4, 0x00, 0xc5, 0x00, 0xc6, 0x00, 0xc7, 0x00,
	0xc8, 0x00, 0xc9, 0x00, 0xca, 0x00, 0xcb, 0x00, 0xcc, 0x00, 0xcd, 0x00, 0xce, 0x00, 0xcf, 0x00,
	0xd0, 0x00, 0xd1, 0x00, 0xd2, 0x00, 0xd3, 0x00, 0xd4, 0x00, 0xd5, 0x00, 0xd6, 0x00, 0xd7, 0x00,
	0xd8, 0x00, 0xd9, 0x00, 0xda, 0x00, 0xdb, 0x00, 0xdc, 0x00, 0xdd, 0x00, 0xde, 0x00, 0xdf, 0x00,
	0xe0, 0x00, 0xe1, 0x00, 0xe2, 0x00, 0xe3, 0x00, 0xe4, 0x00, 0xe5, 0x00, 0xe6, 0x00, 0xe7, 0x00,
	0xe8, 0x00, 0xe9, 0x00, 0xea, 0x00, 0xeb, 0x00, 0xec, 0x00, 0xed, 0x00, 0xee, 0x00, 0xef, 0x00,
	0xf0, 0x00, 0xf1, 0x00, 0xf2, 0x00, 0xf3, 0x00, 0xf4, 0x00, 0xf5, 0x00, 0xf6, 0x00, 0xf7, 0x00,
	0xf8, 0x00, 0xf9, 0x00, 0xfa, 0x00, 0xfb, 0x00, 0xfc, 0x00, 0xfd, 0x00, 0xfe, 0x00, 0xff, 0x00,
	0x00, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x04, 0x01, 0x05, 0x01, 0x06, 0x01, 0x07, 0x01,
	0x08, 0x01, 0x09, 0x01, 0x0a, 0x01, 0x0b, 0x01, 0x0c, 0x01, 0x0d, 0x01, 0x0e, 0x01, 0x0f, 0x01,
	0x10, 0x01, 0x11, 0x01, 0x12, 0x01, 0x13, 0x01, 0x14, 0x01, 0x15, 0x01, 0x16, 0x01, 0x17, 0x01,
	0x18, 0x01, 0x19, 0x01, 0x1a, 0x01, 0x1b, 0x01, 0x1c, 0x01, 0x1d, 0x01, 0x1e, 0x01, 0x1f, 0x01,
	0x20, 0x01, 0x21, 0x01, 0x22, 0x01, 0x23, 0x01, 0x24, 0x01, 0x25, 0x01, 0x26, 0x01, 0x27, 0x01,
	0x28, 0x01, 0x29, 0x01, 0x2a, 0x01, 0x2b, 0x01, 0x2c, 0x01, 0x2d, 0x01, 0x2e, 0x01, 0x2f, 0x01,
	0x30, 0x01, 0x31, 0x01, 0x32, 0x01, 0x33, 0x01, 0x34, 0x01, 0x35, 0x01, 0x36, 0x01, 0x37, 0x01,
	0x38, 0x01, 0x39, 0x01, 0x3a, 0x01, 0x3b, 0x01, 0x3c, 0x01, 0x3d, 0x01, 0x3e, 0x01, 0x3f, 0x01,
	0x40, 0x01, 0x41, 0x01, 0x42, 0x01, 0x43, 0x01, 0x44, 0x01, 0x45, 0x01, 0x46, 0x01, 0x47, 0x01,
	0x48, 0x01, 0x49, 0x01, 0x4a, 0x01, 0x4b, 0x01, 0x4c, 0x01, 0x4d, 0x01, 0x4e, 0x01, 0x4f, 0x01,
	0x50, 0x01, 0x51, 0x01, 0x52, 0x01, 0x53, 0x01, 0x54, 0x01, 0x55, 0x01, 0x56, 0x01, 0x57, 0x01,
	0x58, 0x01, 0x59, 0x01, 0x5a, 0x01, 0x5b, 0x01, 0x5c, 0x01, 0x5d, 0x01, 0x5e, 0x01, 0x5f, 0x01,
	0x60, 0x01, 0x61, 0x01, 0x62, 0x01, 0x63, 0x01, 0x64, 0x01, 0x65, 0x01, 0x66, 0x01, 0x67, 0x01,
	0x68, 0x01, 0x69, 0x01, 0x6a, 0x01, 0x6b, 0x01, 0x6c, 0x01, 0x6d, 0x01, 0x6e, 0x01, 0x6f, 0x01,
	0x70, 0x01, 0x71, 0x01, 0x72, 0x01, 0x73, 0x01, 0x74, 0x01, 0x75, 0x01, 0x76, 0x01, 0x77, 0x01,
	0x78, 0x01, 0x79, 0x01, 0x7a, 0x01, 0x7b, 0x01, 0x7c, 0x01, 0x7d, 0x01, 0x7e, 0x01, 0x7f, 0x01,
	0x80, 0x01, 0x81, 0x01, 0x82, 0x01, 0x83, 0x01, 0x84, 0x01, 0x85, 0x01, 0x86, 0x01, 0x87, 0x01,
	0x88, 0x01, 0x89, 0x01, 0x8a, 0x01, 0x8b, 0x01, 0x8c, 0x01, 0x8d, 0x01, 0x8e, 0x01, 0x8f, 0x01,
	0x90, 0x01, 0x91, 0x01, 0x92, 0x01, 0x93, 0x01, 0x94, 0x01, 0x95, 0x01, 0x96, 0x01, 0x97, 0x01,
	0x98, 0x01, 0x99, 0x01, 0x9a, 0x01, 0x9b, 0x01, 0x9c, 0x01, 0x9d, 0x01, 0x9e, 0x01, 0x9f, 0x01,
	0xa0, 0x01, 0xa1, 0x01, 0xa2, 0x01, 0xa3, 0x01, 0xa4, 0x01, 0xa5, 0x01, 0xa6, 0x01, 0xa7, 0x01,
	0xa8, 0x01, 0xa9, 0x01, 0xaa, 0x01, 0xab, 0x01, 0xac, 0x01, 0xad, 0x01, 0xae, 0x01, 0xaf, 0x01,
	0xb0, 0x01, 0xb1, 0x01, 0xb2, 0x01, 0xb3, 0x01, 0xb4, 0x01, 0xb5, 0x01, 0xb6, 0x01, 0xb7, 0x01,
	0xb8, 0x01, 0xb9, 0x01, 0xba, 0x01, 0xbb, 0x01, 0xbc, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xbf, 0x01,
	0xc0, 0x01, 0xc1, 0x01, 0xc2, 0x01, 0xc3, 0x01, 0xc4, 0x01, 0xc5, 0x01, 0xc6, 0x01, 0xc7, 0x01,
	0xc8, 0x01, 0xc9, 0x01, 0xca, 0x01, 0xcb, 0x01, 0xcc, 0x01, 0xcd, 0x01, 0xce, 0x01, 0xcf, 0x01,
	0xd0, 0x01, 0xd1, 0x01, 0xd2, 0x01, 0xd3, 0x01, 0xd4, 0x01, 0xd5, 0x01, 0xd6, 0x01, 0xd7, 0x01,
	0xd8, 0x01, 0xd9, 0x01, 0xda, 0x01, 0xdb, 0x01, 0xdc, 0x01, 0xdd, 0x01, 0xde, 0x01, 0xdf, 0x01,
	0xe0, 0x01, 0xe1, 0x01, 0xe2, 0x01, 0xe3, 0x01, 0xe4, 0x01, 0xe5, 0x01, 0xe6, 0x01, 0xe7, 0x01,
	0xe8, 0x01, 0xe9, 0x01, 0xea, 0x01, 0xeb, 0x01, 0xec, 0x01, 0xed, 0x01, 0xee, 0x01, 0xef, 0x01,
	0xf0, 0x01, 0xf1, 0x01, 0xf2, 0x01, 0xf3, 0x01, 0xf4, 0x01, 0xf5, 0x01, 0xf6, 0x01, 0xf7, 0x01,
	0xf8, 0x01, 0xf9, 0x01, 0xfa, 0x01, 0xfb, 0x01, 0xfc, 0x01, 0xfd, 0x01, 0xfe, 0x01, 0xff, 0x01,
	0x00, 0x02, 0x01, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04, 0x02, 0x05, 0x02, 0x06, 0x02, 0x07, 0x02,
	0x08, 0x02, 0x09, 0x02, 0x0a, 0x02, 0x0b, 0x02, 0x0c, 0x02, 0x0d, 0x02, 0x0e, 0x02, 0x0f, 0x02,
	0x10, 0x02, 0x11, 0x02, 0x12, 0x02, 0x13, 0x02, 0x14, 0x02, 0x15, 0x02, 0x16, 0x02, 0x17, 0x02,
	0x18, 0x02, 0x19, 0x02, 0x1a, 0x02, 0x1b, 0x02, 0x1c, 0x02, 0x1d, 0x02, 0x1e, 0x02, 0x1f, 0x02,
	0x20, 0x02, 0x21, 0x02, 0x22, 0x02, 0x23, 0x02, 0x24, 0x02, 0x25, 0x02, 0x26, 0x02, 0x27, 0x02,
	0x28, 0x02, 0x29, 0x02, 0x2a, 0x02, 0x2b, 0x02, 0x2c, 0x02, 0x2d, 0x02, 0x2e, 0x02, 0x2f, 0x02,
	0x30, 0x02, 0x31, 0x02, 0x32, 0x02, 0x33, 0x02, 0x34, 0x02, 0x35, 0x02, 0x36, 0x02, 0x37, 0x02,
	0x38, 0x02, 0x39, 0x02, 0x3a, 0x02, 0x3b, 0x02, 0x3c, 0x02, 0x3d, 0x02, 0x3e, 0x02, 0x3f, 0x02,
	0x40, 0x02, 0x41, 0x02, 0x42, 0x02, 0x43, 0x02, 0x44, 0x02, 0x45, 0x02, 0x46, 0x02, 0x47, 0x02,
	0x48, 0x02, 0x49, 0x02, 0x4a, 0x02, 0x4b, 0x02, 0x4c, 0x02, 0x4d, 0x02, 0x4e, 0x02, 0x4f, 0x02,
	0x50, 0x02, 0x51, 0x02, 0x52, 0x02, 0x53, 0x02, 0x54, 0x02, 0x55, 0x02, 0x56, 0x02, 0x57, 0x02,
	0x58, 0x02, 0x59, 0x02, 0x5a, 0x02, 0x5b, 0x02, 0x5c, 0x02, 0x5d, 0x02, 0x5e, 0x02, 0x5f, 0x02,
	0x60, 0x02, 0x61, 0x02, 0x62, 0x02, 0x63, 0x02, 0x64, 0x02, 0x65, 0x02, 0x66, 0x02, 0x67, 0x02,
	0x68, 0x02, 0x69, 0x02, 0x6a, 0x02, 0x6b, 0x02, 0x6c, 0x02, 0x6d, 0x02, 0x6e, 0x02, 0x6f, 0x02,
	0x70, 0x02, 0x71, 0x02, 0x72, 0x02, 0x73, 0x02, 0x74, 0x02, 0x75, 0x02, 0x76, 0x02, 0x77, 0x02,
	0x78, 0x02, 0x79, 0x02, 0x7a, 0x02, 0x7b, 0x02, 0x7c, 0x02, 0x7d, 0x02, 0x7e, 0x02, 0x7f, 0x02,
	0x80, 0x02, 0x81, 0x02, 0x82, 0x02, 0x83, 0x02, 0x84, 0x02, 0x85, 0x02, 0x86, 0x02, 0x87, 0x02,
	0x88, 0x02, 0x89, 0x02, 0x8a, 0x02, 0x8b, 0x02, 0x8c, 0x02, 0x8d, 0x02, 0x8e, 0x02, 0x8f, 0x02,
	0x90, 0x02, 0x91, 0x02, 0x92, 0x02, 0x93, 0x02, 0x94, 0x02, 0x95, 0x02, 0x96, 0x02, 0x97, 0x02,
	0x98, 0x02, 0x99, 0x02, 0x9a, 0x02, 0x9b, 0x02, 0x9c, 0x02, 0x9d, 0x02, 0x9e, 0x02, 0x9f, 0x02,
	0xa0, 0x02, 0xa1, 0x02, 0xa2, 0x02, 0xa3, 0x02, 0xa4, 0x02, 0xa5, 0x02, 0xa6, 0x02, 0xa7, 0x02,
	0xa8, 0x02, 0xa9, 0x02, 0xaa, 0x02, 0xab, 0x02, 0xac, 0x02, 0xad, 0x02, 0xae, 0x02, 0xaf, 0x02,
	0xb0, 0x02, 0xb1, 0x02, 0xb2, 0x02, 0xb3, 0x02, 0xb4, 0x02, 0xb5, 0x02, 0xb6, 0x02, 0xb7, 0x02,
	0xb8, 0x02, 0xb9, 0x02, 0xba, 0x02, 0xbb, 0x02, 0xbc, 0x02, 0xbd, 0x02, 0xbe, 0x02, 0xbf, 0x02,
	0xc0, 0x02, 0xc1, 0x02, 0xc2, 0x02, 0xc3, 0x02, 0xc4, 0x02, 0xc5, 0x02, 0xc6, 0x02, 0xc7, 0x02,
	0xc8, 0x02, 0xc9, 0x02, 0xca, 0x02, 0xcb, 0x02, 0xcc, 0x02, 0xcd, 0x02, 0xce, 0x02, 0xcf, 0x02,
	0xd0, 0x02, 0xd1, 0x02, 0xd2, 0x02, 0xd3, 0x02, 0xd4, 0x02, 0xd5, 0x02, 0xd6, 0x02, 0xd7, 0x02,
	0xd8, 0x02, 0xd9, 0x02, 0xda, 0x02, 0xdb, 0x02, 0xdc, 0x02, 0xdd, 0x02, 0xde, 0x02, 0xdf, 0x02,
	0xe0, 0x02, 0xe1, 0x02, 0xe2, 0x02, 0xe3, 0x02, 0xe4, 0x02, 0xe5, 0x02, 0xe6, 0x02, 0xe7, 0x02,
	0xe8, 0x02, 0xe9, 0x02, 0xea, 0x02, 0xeb, 0x02, 0xec, 0x02, 0xed, 0x02, 0xee, 0x02, 0xef, 0x02,
	0xf0, 0x02, 0xf1, 0x02, 0xf2, 0x02, 0xf3, 0x02, 0xf4, 0x02, 0xf5, 0x02, 0xf6, 0x02, 0xf7, 0x02,
	0xf8, 0x02, 0xf9, 0x02, 0xfa, 0x02, 0xfb, 0x02, 0xfc, 0x02, 0xfd, 0x02, 0xfe, 0x02, 0xff, 0x02,
	0x00, 0x03, 0x01, 0x03, 0x02, 0x03, 0x03, 0x03, 0x04, 0x03, 0x05, 0x03, 0x06, 0x03, 0x07, 0x03,
	0x08, 0x03, 0x09, 0x03, 0x0a, 0x03, 0x0b, 0x03, 0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x03,
	0x10, 0x03, 0x11, 0x03, 0x12, 0x03, 0x13, 0x03, 0x14, 0x03, 0x15, 0x03, 0x16, 0x03, 0x17, 0x03,
	0x18, 0x03, 0x19, 0x03, 0x1a, 0x03, 0x1b, 0x03, 0x1c, 0x03, 0x1d, 0x03, 0x1e, 0x03, 0x1f, 0x03,
	0x20, 0x03, 0x21, 0x03, 0x22, 0x03, 0x23, 0x03, 0x24, 0x03, 0x25, 0x03, 0x26, 0x03, 0x27, 0x03,
	0x28, 0x03, 0x29, 0x03, 0x2a, 0x03, 0x2b, 0x03, 0x2c, 0x03, 0x2d, 0x03, 0x2e, 0x03, 0x2f, 0x03,
	0x30, 0x03, 0x31, 0x03, 0x32, 0x03, 0x33, 0x03, 0x34, 0x03, 0x35, 0x03, 0x36, 0x03, 0x37, 0x03,
	0x38, 0x03, 0x39, 0x03, 0x3a, 0x03, 0x3b, 0x03, 0x3c, 0x03, 0x3d, 0x03, 0x3e, 0x03, 0x3f, 0x03,
	0x40, 0x03, 0x41, 0x03, 0x42, 0x03, 0x43, 0x03, 0x44, 0x03, 0x45, 0x03, 0x46, 0x03, 0x47, 0x03,
	0x48, 0x03, 0x49, 0x03, 0x4a, 0x03, 0x4b, 0x03, 0x4c, 0x03, 0x4d, 0x03, 0x4e, 0x03, 0x4f, 0x03,
	0x50, 0x03, 0x51, 0x03, 0x52, 0x03, 0x53, 0x03, 0x54, 0x03, 0x55, 0x03, 0x56, 0x03, 0x57, 0x03,
	0x58, 0x03, 0x59, 0x03, 0x5a, 0x03, 0x5b, 0x03, 0x5c, 0x03, 0x5d, 0x03, 0x5e, 0x03, 0x5f, 0x03,
	0x60, 0x03, 0x61, 0x03, 0x62, 0x03, 0x63, 0x03, 0x64, 0x03, 0x65, 0x03, 0x66, 0x03, 0x67, 0x03,
	0x68, 0x03, 0x69, 0x03, 0x6a, 0x03, 0x6b, 0x03, 0x6c, 0x03, 0x6d, 0x03, 0x6e, 0x03, 0x6f, 0x03,
	0x70, 0x03, 0x71, 0x03, 0x72, 0x03, 0x73, 0x03, 0x74, 0x03, 0x75, 0x03, 0x76, 0x03, 0x77, 0x03,
	0x78, 0x03, 0x79, 0x03, 0x7a, 0x03, 0x7b, 0x03, 0x7c, 0x03, 0x7d, 0x03, 0x7e, 0x03, 0x7f, 0x03,
	0x80, 0x03, 0x81, 0x03, 0x82, 0x03, 0x83, 0x03, 0x84, 0x03, 0x85, 0x03, 0x86, 0x03, 0x87, 0x03,
	0x88, 0x03, 0x89, 0x03, 0x8a, 0x03, 0x8b, 0x03, 0x8c, 0x03, 0x8d, 0x03, 0x8e, 0x03, 0x8f, 0x03,
	0x90, 0x03, 0x91, 0x03, 0x92, 0x03, 0x93, 0x03, 0x94, 0x03, 0x95, 0x03, 0x96, 0x03, 0x97, 0x03,
	0x98, 0x03, 0x99, 0x03, 0x9a, 0x03, 0x9b, 0x03, 0x9c, 0x03, 0x9d, 0x03, 0x9e, 0x03, 0x9f, 0x03,
	0xa0, 0x03, 0xa1, 0x03, 0xa2, 0x03, 0xa3, 0x03, 0xa4, 0x03, 0xa5, 0x03, 0xa6, 0x03, 0xa7, 0x03,
	0xa8, 0x03, 0xa9, 0x03, 0xaa, 0x03, 0xab, 0x03, 0xac, 0x03, 0xad, 0x03, 0xae, 0x03, 0xaf, 0x03,
	0xb0, 0x03, 0xb1, 0x03, 0xb2, 0x03, 0xb3, 0x03, 0xb4, 0x03, 0xb5, 0x03, 0xb6, 0x03, 0xb7, 0x03,
	0xb8, 0x03, 0xb9, 0x03, 0xba, 0x03, 0xbb, 0x03, 0xbc, 0x03, 0xbd, 0x03, 0xbe, 0x03, 0xbf, 0x03,
	0xc0, 0x03, 0xc1, 0x03, 0xc2, 0x03, 0xc3, 0x03, 0xc4, 0x03, 0xc5, 0x03, 0xc6, 0x03, 0xc7, 0x03,
	0xc8, 0x03, 0xc9, 0x03, 0xca, 0x03, 0xcb, 0x03, 0xcc, 0x03, 0xcd, 0x03, 0xce, 0x03, 0xcf, 0x03,
	0xd0, 0x03, 0xd1, 0x03, 0xd2, 0x03, 0xd3, 0x03, 0xd4, 0x03, 0xd5, 0x03, 0xd6, 0x03, 0xd7, 0x03,
	0xd8, 0x03, 0xd9, 0x03, 0xda, 0x03, 0xdb, 0x03, 0xdc, 0x03, 0xdd, 0x03, 0xde, 0x03, 0xdf, 0x03,
	0xe0, 0x03, 0xe1, 0x03, 0xe2, 0x03, 0xe3, 0x03, 0xe4, 0x03, 0xe5, 0x03, 0xe6, 0x03, 0xe7, 0x03
};

static std::vector<std::string> crcDisasmFull = {
    "loadConst 0x2710, r14",
    "loadConst 0xffffffff, r10",
    "loadConst 0x0, r11",
    "loadConst 0x0, r12",
    "loadConst 0x1, r13",
    "loadConst 0x4, r9",
    "sub_1b0:",
    "read r12, r13, r11, r0",
    "jumpEqual sub_3da, r0, r11",
    "mov byte[r11], r3",
    "call sub_bd1",
    "call sub_ee1",
    "call sub_49d",
    "mov r0, byte[r11]",
    "mov byte[r11], r0",
    "mul r0, r9, r0",
    "add r0, r13, r0",
    "mov dword[r0], r0",
    "loadConst 0x100, r1",
    "div r10, r1, r10",
    "call sub_ee1",
    "call sub_a81",
    "call sub_49d",
    "mov r0, r10",
    "add r12, r13, r12",
    "jump sub_1b0",
    "sub_3da:",
    "loadConst 0xffffffff, r11",
    "call sub_f51",
    "call sub_ee1",
    "call sub_49d",
    "consoleWrite r0",
    "hlt",
    "sub_49d:",
    "call sub_1111",
    "call sub_10a1",
    "call sub_b61",
    "call sub_bd1",
    "call sub_c41",
    "call sub_cb1",
    "call sub_d21",
    "call sub_d91",
    "call sub_e01",
    "call sub_ee1",
    "sub r10, r10, r10",
    "sub r2, r2, r2",
    "loadConst 0x2, r7",
    "loadConst 0x8000000000000000, r3",
    "mov r3, r4",
    "loadConst 0xffffffffffffffff, r8",
    "sub_714:",
    "jumpEqual sub_768, r0, r2",
    "jump sub_797",
    "sub_768:",
    "jumpEqual sub_950, r1, r2",
    "sub_797:",
    "compare r0, r2, r5",
    "compare r1, r2, r6",
    "compare r5, r8, r5",
    "compare r6, r8, r6",
    "jumpEqual sub_850, r5, r6",
    "add r10, r4, r10",
    "jump sub_850",
    "sub_850:",
    "jumpEqual sub_8b9, r3, r4",
    "div r4, r7, r4",
    "jump sub_901",
    "sub_8b9:",
    "loadConst 0x4000000000000000, r4",
    "sub_901:",
    "mul r0, r7, r0",
    "mul r1, r7, r1",
    "jump sub_714",
    "sub_950:",
    "mov r10, r0",
    "call sub_1501",
    "call sub_1421",
    "call sub_13b1",
    "call sub_1341",
    "call sub_12d1",
    "call sub_1261",
    "call sub_11f1",
    "call sub_1181",
    "ret",
    "sub_a81:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r0, qword[r14]",
    "ret",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r1, qword[r14]",
    "ret",
    "sub_b61:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r2, qword[r14]",
    "ret",
    "sub_bd1:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r3, qword[r14]",
    "ret",
    "sub_c41:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r4, qword[r14]",
    "ret",
    "sub_cb1:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r5, qword[r14]",
    "ret",
    "sub_d21:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r6, qword[r14]",
    "ret",
    "sub_d91:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r7, qword[r14]",
    "ret",
    "sub_e01:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r8, qword[r14]",
    "ret",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r9, qword[r14]",
    "ret",
    "sub_ee1:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r10, qword[r14]",
    "ret",
    "sub_f51:",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r11, qword[r14]",
    "ret",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r12, qword[r14]",
    "ret",
    "loadConst 0x8, r2",
    "add r14, r2, r14",
    "mov r13, qword[r14]",
    "ret",
    "sub_10a1:",
    "loadConst 0x8, r2",
    "mov qword[r14], r0",
    "sub r14, r2, r14",
    "ret",
    "sub_1111:",
    "loadConst 0x8, r2",
    "mov qword[r14], r1",
    "sub r14, r2, r14",
    "ret",
    "sub_1181:",
    "loadConst 0x8, r2",
    "mov qword[r14], r2",
    "sub r14, r2, r14",
    "ret",
    "sub_11f1:",
    "loadConst 0x8, r2",
    "mov qword[r14], r3",
    "sub r14, r2, r14",
    "ret",
    "sub_1261:",
    "loadConst 0x8, r2",
    "mov qword[r14], r4",
    "sub r14, r2, r14",
    "ret",
    "sub_12d1:",
    "loadConst 0x8, r2",
    "mov qword[r14], r5",
    "sub r14, r2, r14",
    "ret",
    "sub_1341:",
    "loadConst 0x8, r2",
    "mov qword[r14], r6",
    "sub r14, r2, r14",
    "ret",
    "sub_13b1:",
    "loadConst 0x8, r2",
    "mov qword[r14], r7",
    "sub r14, r2, r14",
    "ret",
    "sub_1421:",
    "loadConst 0x8, r2",
    "mov qword[r14], r8",
    "sub r14, r2, r14",
    "ret",
    "loadConst 0x8, r2",
    "mov qword[r14], r9",
    "sub r14, r2, r14",
    "ret",
    "sub_1501:",
    "loadConst 0x8, r2",
    "mov qword[r14], r10",
    "sub r14, r2, r14",
    "ret",
    "loadConst 0x8, r2",
    "mov qword[r14], r11",
    "sub r14, r2, r14",
    "ret",
    "loadConst 0x8, r2",
    "mov qword[r14], r12",
    "sub r14, r2, r14",
    "ret",
    "loadConst 0x8, r2",
    "mov qword[r14], r13",
    "sub r14, r2, r14",
    "ret"
};

static std::string testPath = STR(TEST_FOLDER);

bool areInstructionsEqual(const std::vector<EVMInstruction>& vec1, const std::vector<EVMInstruction>& vec2) 
{
	if (vec1.size() != vec2.size()) 
	{
		return false; // Different sizes, not equal
	}
	for (size_t i = 0; i < vec1.size(); ++i) 
	{
		if (vec1[i].opcode != vec2[i].opcode) 
		{
			return false; // Different opcodes, not equal
		}

		if (vec1[i].arguments.size() != vec2[i].arguments.size()) 
		{
			return false; // Different argument vector sizes, not equal
		}

		// Compare each argument
		for (size_t j = 0; j < vec1[i].arguments.size(); ++j) 
		{
			// Assuming you have appropriate comparison logic for your union and structs
			if (vec1[i].arguments[j].type != vec2[i].arguments[j].type)
			{
				return false;
			}
			if (vec1[i].arguments[j].type == ArgumentType::CONSTANT)
			{
				if (vec1[i].arguments[j].data.constant != vec2[i].arguments[j].data.constant)
				{
					return false;
				}
			}
			else if (vec1[i].arguments[j].type == ArgumentType::ADDRESS)
			{
				if (vec1[i].arguments[j].data.codeAddress != vec2[i].arguments[j].data.codeAddress)
				{
					return false;
				}
			}
			else if (vec1[i].arguments[j].type == ArgumentType::DATA_ACCESS)
			{
				if (vec1[i].arguments[j].data.dataAccess.type != vec2[i].arguments[j].data.dataAccess.type)
				{
					return false;
				}
				if ((vec1[i].arguments[j].data.dataAccess.accessSize != vec2[i].arguments[j].data.dataAccess.accessSize) ||
					 vec1[i].arguments[j].data.dataAccess.registerIndex != vec2[i].arguments[j].data.dataAccess.registerIndex)
				{
					return false;
				}
			}
		}
	}
	return true; // All elements are equal
}

void initializeCrcInstructionsTest()
{
	EVMInstruction i1{}; i1.opcode = EVMOpcode::LOADCONST;
	EVMArgument const1{}; const1.type = ArgumentType::CONSTANT; const1.data.constant = static_cast<int64_t>(10000); i1.arguments.push_back(const1);
	EVMArgument arg1{}; arg1.type = ArgumentType::DATA_ACCESS;  arg1.data.dataAccess.type = DataAccessType::REGISTER; arg1.data.dataAccess.accessSize = MemoryAccessSize::NONE; arg1.data.dataAccess.registerIndex = 14; i1.arguments.push_back(arg1);
	crcInstructionsTest.push_back(i1);

	EVMInstruction i2{}; i2.opcode = EVMOpcode::LOADCONST;
	EVMArgument const2{}; const2.type = ArgumentType::CONSTANT; const2.data.constant = static_cast<int64_t>(0xFFFFFFFF); i2.arguments.push_back(const2);
	EVMArgument arg1_1{}; arg1_1.type = ArgumentType::DATA_ACCESS; arg1_1.data.dataAccess.type = DataAccessType::REGISTER; arg1_1.data.dataAccess.accessSize = MemoryAccessSize::NONE; arg1_1.data.dataAccess.registerIndex = 10; i2.arguments.push_back(arg1_1);
	crcInstructionsTest.push_back(i2);

	EVMInstruction i3{}; i3.opcode = EVMOpcode::LOADCONST;
	EVMArgument const3{}; const3.type = ArgumentType::CONSTANT; const3.data.constant = static_cast<int64_t>(0); i3.arguments.push_back(const3);
	EVMArgument arg1_2{}; arg1_2.type = ArgumentType::DATA_ACCESS; arg1_2.data.dataAccess.type = DataAccessType::REGISTER; arg1_2.data.dataAccess.accessSize = MemoryAccessSize::NONE; arg1_2.data.dataAccess.registerIndex = 11; i3.arguments.push_back(arg1_2);
	crcInstructionsTest.push_back(i3);

	EVMInstruction i4{}; i4.opcode = EVMOpcode::LOADCONST;
	EVMArgument const4{}; const4.type = ArgumentType::CONSTANT; const4.data.constant = static_cast<int64_t>(0); i4.arguments.push_back(const4);
	EVMArgument arg1_3{}; arg1_3.type = ArgumentType::DATA_ACCESS; arg1_3.data.dataAccess.type = DataAccessType::REGISTER; arg1_3.data.dataAccess.accessSize = MemoryAccessSize::NONE; arg1_3.data.dataAccess.registerIndex = 12; i4.arguments.push_back(arg1_3);
	crcInstructionsTest.push_back(i4);

	EVMInstruction i5{}; i5.opcode = EVMOpcode::LOADCONST;
	EVMArgument const5{}; const5.type = ArgumentType::CONSTANT; const5.data.constant = static_cast<int64_t>(1); i5.arguments.push_back(const5);
	EVMArgument arg1_4{}; arg1_4.type = ArgumentType::DATA_ACCESS; arg1_4.data.dataAccess.type = DataAccessType::REGISTER; arg1_4.data.dataAccess.accessSize = MemoryAccessSize::NONE; arg1_4.data.dataAccess.registerIndex = 13; i5.arguments.push_back(arg1_4);
	crcInstructionsTest.push_back(i5);

	EVMInstruction i6{}; i6.opcode = EVMOpcode::LOADCONST;
	EVMArgument const6{}; const6.type = ArgumentType::CONSTANT; const6.data.constant = static_cast<int64_t>(4); i6.arguments.push_back(const6);
    EVMArgument arg1_5{}; arg1_5.type = ArgumentType::DATA_ACCESS; arg1_5.data.dataAccess.type = DataAccessType::REGISTER; arg1_5.data.dataAccess.accessSize = MemoryAccessSize::NONE; arg1_5.data.dataAccess.registerIndex = 9; i6.arguments.push_back(arg1_5);
	crcInstructionsTest.push_back(i6);

	EVMInstruction i7{}; i7.opcode = EVMOpcode::RET;
	crcInstructionsTest.push_back(i7);
}

TEST(DisassembleTest, ParsingInstruction)
{
	EVMDisasm disasm(crcCodeTest);

	initializeCrcInstructionsTest();
	std::vector<EVMInstruction> instructions;
    const auto parsingInstruction = disasm.parseInstructions();
    if (parsingInstruction.has_value())
    {
        instructions = parsingInstruction.value();
    }
	EXPECT_TRUE(parsingInstruction.has_value());
	EXPECT_TRUE(instructions.size() > 0);
	EXPECT_TRUE(areInstructionsEqual(instructions, crcInstructionsTest));

	std::vector<std::string> sourceCodeLines{};
    const auto sourceCodeTransform = disasm.convertInstructionsToSourceCode(instructions);
    if (sourceCodeTransform.has_value())
    {
        sourceCodeLines = sourceCodeTransform.value();
    }
	EXPECT_TRUE(sourceCodeTransform.has_value());
}

TEST(BitStreamReaderTest, CrcTest)
{
	BitStreamReader bitStreamReader (crcCodeTest);
	std::vector<bool> bitStream;
	const auto bitStreamResult = bitStreamReader.readBits(crcCodeTest.size() * BITS_IN_BYTE, false);
	EXPECT_TRUE(bitStreamResult.has_value());
	bitStream = bitStreamResult.value();
	std::string bitStreamString {};
	for (const auto& bit : bitStream)
	{
		bitStreamString += (bit ? "1" : "0");
	}
	EXPECT_EQ(bitStreamString, crcBitStreamTest);
}
TEST(DisassembleTest, InstructionParsingCrcTest)
{
	EVMDisasm disasm(crcCodeFull);
	EXPECT_EQ(disasm.getError(), ESETVMStatus::SUCCESS);
	std::vector<EVMInstruction> instructions;
    const auto instructionParsing = disasm.parseInstructions();
    if (instructionParsing.has_value())
    {
		instructions = instructionParsing.value();
    }
	EXPECT_TRUE(instructionParsing.has_value());
	EXPECT_TRUE(instructions.size() > 0);
	std::vector<std::string> sourceCodeLines{};
    const auto sourceCodeTransform = disasm.convertInstructionsToSourceCode(instructions);
    if (sourceCodeTransform.has_value())
    {
        sourceCodeLines = sourceCodeTransform.value();
    }
	EXPECT_TRUE(sourceCodeTransform.has_value());
	EXPECT_TRUE(std::equal(sourceCodeLines.begin(), sourceCodeLines.end(), crcDisasmFull.begin(), crcDisasmFull.end()));
}
TEST(CliTest, CliArguments)
{
	int argc = 2;
	const char* argv [2] {"", "-r"};
	CLIArgParser parse1 {argc, argv};
	EXPECT_FALSE(parse1.parseArguments());
	
	argc = 3;
	const char* argv2[3] {"", "-v", "-h"};
	CLIArgParser parse2 {argc, argv2};
	EXPECT_TRUE(parse2.parseArguments());
	EXPECT_TRUE(parse2.getFlags().verbose);
	EXPECT_TRUE(parse2.getFlags().help);
	
	argc = 4;
	std::string inputPath1 = testPath + "/samples/precompiled/crc.evm";
	const char* argv3[4] {"","-d", inputPath1.c_str(), "output_file.txt"};
	CLIArgParser parse3 {argc, argv3};
	EXPECT_TRUE(parse3.parseArguments());
	EXPECT_TRUE(parse3.getFlags().disassemble);
	EXPECT_EQ(parse3.getInputPath(), inputPath1);
	EXPECT_EQ(parse3.getOutputPath(),"output_file.txt");
	
	argc = 3;
	const char* argv4[3] {"","-r","output_file.txt"};
	CLIArgParser parse4 {argc, argv4};
	EXPECT_FALSE(parse4.parseArguments());
	
	
	argc = 6;
	std::string binaryPath = testPath + "/samples/crc.bin";
	const char* argv5[] {"","-d", inputPath1.c_str(), "output_file.txt", "-b", binaryPath.c_str()};
	CLIArgParser parse5 {argc, argv5};
	EXPECT_FALSE(parse5.parseArguments());
	
	argc = 3;
	const char* argv6[] {"","-b", binaryPath.c_str()};
	CLIArgParser parse6 {argc, argv6};
	EXPECT_FALSE(parse6.parseArguments());
	
	argc = 8;
	const char* argv7[] {"","-b", binaryPath.c_str(), "-r", inputPath1.c_str(), "-d", inputPath1.c_str(), "-h"};
	CLIArgParser parse7 {argc, argv7};
	EXPECT_FALSE(parse7.parseArguments());
	
	argc = 5;
	const char* argv8[] {"","-b", binaryPath.c_str(), "-r", inputPath1.c_str()};
	CLIArgParser parse8 {argc, argv8};
	EXPECT_TRUE(parse8.parseArguments());
	EXPECT_TRUE(parse8.getFlags().binaryFile);
	EXPECT_TRUE(parse8.getFlags().run);
	EXPECT_EQ(parse8.getInputPath(), inputPath1);
	EXPECT_EQ(parse8.getBinaryFilePath(), binaryPath);
}

std::vector<std::string> getAllFilesInDirectory(const std::string& directoryPath) 
{
	std::vector<std::string> files {};
	for (const auto& entry : std::filesystem::directory_iterator(directoryPath))
	{
		if (std::filesystem::is_regular_file(entry.path()))
		{
			files.push_back(entry.path().string());
		}
	}
	return files;
}

TEST(DisassembleTest, DisassembleAllProvidedSamples)
{
	std::string evmFilesFolder = testPath + "/samples/precompiled/";
	std::string outputFileFolder = testPath + "/samples/recompile_test/";
	if (!std::filesystem::exists(outputFileFolder))
	{
		std::filesystem::create_directories(outputFileFolder);
	}
	std::vector<std::string> evmFilePaths = getAllFilesInDirectory(evmFilesFolder);
	for (const auto& filePath : evmFilePaths)
	{
		if(filePath.ends_with(".evm"))
		{
			std::filesystem::path path(filePath);
			std::string fileName = path.stem().string();
			std::string outputFilePath = outputFileFolder + fileName + "_decompiled.easm";
			
			ESETVM evm {filePath, outputFilePath, false};
			EXPECT_EQ(evm.init(), ESETVMStatus::SUCCESS);
			EXPECT_EQ(evm.saveSourceCode(), ESETVMStatus::SUCCESS);
			
			std::string recompiledPath = outputFileFolder + fileName + "_recompiled.evm";
			std::string command = "python2 " + testPath + "/compiler.py " + outputFilePath + " " + recompiledPath;
			EXPECT_FALSE(std::system(command.c_str())); // recompile samples using provided python script
						
			std::ifstream file1(filePath, std::ios::binary);
			std::ifstream file2(recompiledPath, std::ios::binary);

			EXPECT_FALSE (!file1.is_open() || !file2.is_open());
			EXPECT_FALSE (std::filesystem::file_size(filePath) != std::filesystem::file_size(recompiledPath));

			std::vector<char> content1(std::istreambuf_iterator<char>(file1), {});
			std::vector<char> content2(std::istreambuf_iterator<char>(file2), {});
			EXPECT_TRUE(content1.size() == content2.size());
			EXPECT_TRUE(std::equal(content1.begin(), content1.end(), content2.begin()));
		}
	}
}
std::optional<std::string> getOutputEmulation(std::string path, const std::vector<std::string>& inputs, bool verbose, std::string binaryFilePath = "")
{
	std::ostringstream concatInput;
	for (const auto& input: inputs)
	{
		if (input.length() > 0)
		{
			concatInput << input << std::endl;
		}
	}
	
	std::istringstream inputStream(concatInput.str());
	std::ostringstream outputStream;
	
	std::streambuf* coutbuf = std::cout.rdbuf();
	std::streambuf* cinbuf = std::cin.rdbuf();
	
	std::cout.rdbuf(outputStream.rdbuf());
	std::cin.rdbuf(inputStream.rdbuf());
	
	ESETVM evm {path, "", verbose};
	if (evm.init() != ESETVMStatus::SUCCESS)
	{
		std::cout.rdbuf(coutbuf);
		std::cin.rdbuf(cinbuf);
		return std::nullopt;
	}
	if (evm.run(binaryFilePath) != ESETVMStatus::SUCCESS)
	{
		std::cout.rdbuf(coutbuf);
		std::cin.rdbuf(cinbuf);
		return std::nullopt;
	}
	std::cout.rdbuf(coutbuf);
	std::cin.rdbuf(cinbuf);

	std::string output {outputStream.str()};
	return output;
}

TEST (EmulationTest, Math)
{
	auto start = std::chrono::high_resolution_clock::now();
	
	std::string mathEvm = testPath + "/samples/precompiled/math.evm";
	const auto mathResult = getOutputEmulation(mathEvm, {""}, false);
	EXPECT_TRUE(mathResult.has_value());
	EXPECT_EQ(mathResult.value(), "0000000000000118\n00000000000000e8\n000000000000000a\n0000000000000010\n0000000000001800\n0000000000000001\n");
	
	auto end = std::chrono::high_resolution_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	std::cout << "Execution time: " << duration.count() << " us" << std::endl;
}
TEST (EmulationTest, Fibonacci)
{
	auto start = std::chrono::high_resolution_clock::now();
	
	std::string fibonacciEvm = testPath + "/samples/precompiled/fibonacci_loop.evm";
	const auto fibonacciResult = getOutputEmulation(fibonacciEvm, {"5"}, false);
	EXPECT_TRUE(fibonacciResult.has_value());
	EXPECT_EQ(fibonacciResult.value(), "0000000000000001\n0000000000000001\n0000000000000002\n0000000000000003\n0000000000000005\n"); // not valid fibonacci sequence
	
	auto end = std::chrono::high_resolution_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	std::cout << "Execution time: " << duration.count() << " us" << std::endl;
}
TEST (EmulationTest, Memory)
{
	auto start = std::chrono::high_resolution_clock::now();
	
	std::string memoryEvm = testPath + "/samples/precompiled/memory.evm";
	const auto memoryResult = getOutputEmulation(memoryEvm, {""}, false);
	EXPECT_TRUE(memoryResult.has_value());
	EXPECT_EQ(memoryResult.value(),  "0123456789abcdef\n0000000089abcdef\n000000000000cdef\n00000000000000ef\n0000000001234567\n0000000001234567\n0000000000004567\n0000000000000067\n0000000000000000\n0000000000000000\n0000000000000000\n0000000000000000\n");
	
	auto end = std::chrono::high_resolution_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	std::cout << "Execution time: " << duration.count() << " us" << std::endl;
}
TEST (EmulationTest, Xor)
{
	auto start = std::chrono::high_resolution_clock::now();
	
	std::string xorEvm = testPath + "/samples/precompiled/xor.evm";
	const auto xorResult = getOutputEmulation(xorEvm, {"123456", "98765"}, false);
	EXPECT_TRUE(xorResult.has_value());
	EXPECT_EQ(xorResult.value(), "00000000001bb333\n");
	
	auto end = std::chrono::high_resolution_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	std::cout << "Execution time: " << duration.count() << " us" << std::endl;
}
TEST (EmulationTest, XorWithStackFrame)
{
	auto start = std::chrono::high_resolution_clock::now();
	
	std::string xorWithStackFrameEvm = testPath + "/samples/precompiled/xor-with-stack-frame.evm";
	const auto xorWithStackFrameResult = getOutputEmulation(xorWithStackFrameEvm, {"123456", "98765"}, false);
	EXPECT_TRUE(xorWithStackFrameResult.has_value());
	EXPECT_EQ(xorWithStackFrameResult.value(), "00000000001bb333\n");
	
	auto end = std::chrono::high_resolution_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	std::cout << "Execution time: " << duration.count() << " us" << std::endl;
}
TEST (EmulationTest, Crc)
{
	auto start = std::chrono::high_resolution_clock::now();
	
	std::string crcEvm = testPath + "/samples/precompiled/crc.evm";
	std::string crcBin = testPath + "/samples/crc.bin";
	const auto crcResult = getOutputEmulation(crcEvm, {""}, false, crcBin);
	EXPECT_TRUE(crcResult.has_value());
	EXPECT_EQ(crcResult.value(), "000000008407759b\n");
	
	auto end = std::chrono::high_resolution_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	std::cout << "Execution time: " << duration.count() << " us" << std::endl;
}
TEST (EmulationTest, ThreadingBase)
{
	auto start = std::chrono::high_resolution_clock::now();
	
	std::string threadingBaseEvm = testPath + "/samples/precompiled/threadingBase.evm";
	const auto threadingBaseResult = getOutputEmulation(threadingBaseEvm, {""}, false);
	EXPECT_TRUE(threadingBaseResult.has_value());
	EXPECT_EQ(threadingBaseResult.value(), "0123456789abcdef\n");
	
	auto end = std::chrono::high_resolution_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	std::cout << "Execution time: " << duration.count() << " us" << std::endl;
}
TEST (EmulationTest, Lock)
{
	auto start = std::chrono::high_resolution_clock::now();
	
	std::string lockEvm = testPath + "/samples/precompiled/lock.evm";
	const auto lockResult = getOutputEmulation(lockEvm, {""}, false);
	EXPECT_TRUE(lockResult.has_value());
	EXPECT_EQ(lockResult.value(), "0000000000000300\n");
	
	auto end = std::chrono::high_resolution_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	std::cout << "Execution time: " << duration.count() << " us" << std::endl;
}
TEST (EmulationTest, MultiThreadedFileWrite)
{
	auto start = std::chrono::high_resolution_clock::now();
	
	std::string multiThreadedFileWriteEvm = testPath + "/samples/precompiled/multithreaded_file_write.evm";
	std::string multiThreadedFileWriteBin = testPath + "/samples/multithreaded_file_write.bin";
	
	std::ifstream fInBefore {multiThreadedFileWriteBin, std::ios::in | std::ios::binary};
	EXPECT_TRUE(fInBefore.is_open());
	
	std::vector<uint8_t> fileContentsBefore;
	std::copy(std::istreambuf_iterator<char>(fInBefore),
			  std::istreambuf_iterator<char>(),
			  std::back_inserter(fileContentsBefore));
	fInBefore.close();
	
	EXPECT_TRUE(std::equal(fileContentsBefore.cbegin(), fileContentsBefore.cend(), multithreadedFileWrite.cbegin(), multithreadedFileWrite.cend()));
	
	ESETVM evm {multiThreadedFileWriteEvm, "", false};
	EXPECT_EQ(evm.init(), ESETVMStatus::SUCCESS);
	EXPECT_EQ(evm.run(multiThreadedFileWriteBin), ESETVMStatus::SUCCESS);
	
	std::ifstream fInAfter {multiThreadedFileWriteBin, std::ios::in | std::ios::binary};
	EXPECT_TRUE(fInAfter.is_open());
	
	std::vector<uint8_t> fileContentsAfter;
	std::copy(std::istreambuf_iterator<char>(fInAfter),
			  std::istreambuf_iterator<char>(),
			  std::back_inserter(fileContentsAfter));
	
	fInAfter.close();
	
	std::ofstream fOriginalFileRestore {multiThreadedFileWriteBin, std::ios::out | std::ios::binary};
	fOriginalFileRestore.write(reinterpret_cast<const char*>(multithreadedFileWrite.data()), multithreadedFileWrite.size());
	EXPECT_EQ(fOriginalFileRestore.bad(), false);
	EXPECT_EQ(fOriginalFileRestore.fail(), false);
	fOriginalFileRestore.close();
	
	EXPECT_TRUE(std::equal(fileContentsBefore.cbegin(), fileContentsBefore.cend(), fileContentsAfter.cbegin(), fileContentsAfter.cend()));
	
	auto end = std::chrono::high_resolution_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	std::cout << "Execution time: " << duration.count() << " us" << std::endl;
}
TEST (EmulationTest, PseudoRandom)
{
	std::string pseudoRandomEvm = testPath + "/samples/precompiled/pseudorandom.evm";
	const auto pseudorandomResult = getOutputEmulation(pseudoRandomEvm, {"123"}, false);
	EXPECT_TRUE(pseudorandomResult.has_value());
	EXPECT_TRUE(pseudorandomResult.value().size() == 17);
}
TEST (EmulationTest, Philosophers)
{
	std::string philosophersEvm = testPath + "/samples/precompiled/philosophers.evm";
	
	std::istringstream inputStream("5");
	std::streambuf* cinbuf = std::cin.rdbuf();
	std::cin.rdbuf(inputStream.rdbuf());
	std::cout.rdbuf(nullptr);
	
	ESETVM evm {philosophersEvm, "", false};
	EXPECT_EQ(evm.init(), ESETVMStatus::SUCCESS);
	EXPECT_EQ(evm.run("", 1000), ESETVMStatus::EMULATION_INS_NUM_EXCEEDED);
	
	std::cin.rdbuf(cinbuf);
}
